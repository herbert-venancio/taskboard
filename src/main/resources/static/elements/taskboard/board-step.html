<!--
  [LICENSE]
  Taskboard
  ---
  Copyright (C) 2015 - 2016 Objective Solutions
  ---
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Affero General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU Affero General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  [/LICENSE]
  -->

<dom-module id="board-step">
    <style>
    	
    	.step-count-wrapper {
    		width: 100%;
    	}
		
		.step-count {
			background: #777;
			display: inline-block;
			padding: 3px 10px;
			color: #FFF;
			border-radius: 3px;
			margin: 3px;
			font-size: 13px;
		}
		
    </style>

    <template>
        <iron-signals on-iron-signal-update-user-preferences="preferencesUpdated"
                      on-iron-signal-config-visibility-synthetic-changed="preferencesUpdated"
                      on-iron-signal-search-filter-changed="searchFilterChanged"
                      on-iron-signal-level-config-changed="preferencesUpdated"
                      on-iron-signal-hierarchical-filter-changed="preferencesUpdated"
                      on-iron-signal-issues-updated="handleUpdatedIssues"
                      ></iron-signals>
        <div id="boardStep" class="wrap layout horizontal sortable-board-step" style="width: 100%">

            <!-- Issue Counter -->
            <template is="dom-if" if="{{showTeamCount(issues, lastPreferenceUpdate)}}">
                <div style="width:100%" class="step-count-wrapper layout horizontal">
					<inline-badge class="step-count" value="{{getIssueCount(issues, lastPreferenceUpdate)}}"></inline-badge>
                </div>
            </template>

            <!-- Issues -->
            <template is="dom-repeat" items="{{filteredIssues}}" as="issue" sort="{{getSorter()}}">
                <issue-item id='{{issue.issueKey}}' item="{{issue}}" boardstepid="{{stepMetadata.id}}" style$="{{getOptimalIssueWidth(columns, issue)}}" hidden="{{showSynthetic(lastPreferenceUpdate)}}"></issue-item>
                <issue-item-synthetic item="{{issue}}" parent-type-icon="{{showParentIconInSynthetic(parentLaneConfig)}}" hidden="{{!showSynthetic(lastPreferenceUpdate)}}"></issue-item-synthetic>
            </template>
        </div>
    </template>

    <script>
        var checkingInvalidTeam = false;

        var sortIssue = new function () {
            var compareElements = function (a, b) {
                return (a === b) ? 0 : ((a < b) ? 1 : -1);
            };

            var sortByCreated = function (a, b) {
                return compareElements(-a.created, -b.created);
            };
            
            this.sortByOrder = function (a, b) {
            	return a.priorityOrder-b.priorityOrder;
            };
        }();


        (function () {
            Polymer({
                is: 'board-step',

                behaviors: [
                    Polymer.IronResizableBehavior
                ],

                properties: {
                    parentLaneConfig: {
                        type: Object
                    },
                    stepMetadata: {
                        type: Object
                    },
                    parentLaneId: {
                        type: Number
                    },
                    issues: {
                        type: Array,
                        notify: true,
                        observer: 'preferencesUpdated'
                    },
                    filteredIssues: {
                        type: Array,
                        value: []
                    },
                    team: {
                        type: String
                    },
                    lastPreferenceUpdate: {
                        type: Date,
                        value: new Date(),
                        notify: true
                    },
                    columns: {
                        type: Number,
                        value: 1
                    },
                    idealIssueSize: {
                        type: Number,
                        value: 150
                    },
                    search: {
                        type: Object
                    }
                },

                listeners: {
                    'iron-resize': 'refit'
                },
                
                attached: function() {
                	if (this.stepItem().length == 0) {
                		throw "Failed to enable prioritization because the step item could not be found";
                	}
                	this.makeStepSortable();
                },
                
                makeStepSortable: function() {
                	var handle = function(e,ui) {
            			var si = this.stepItem();
            			var issueKeysEl = si.find("input[type='hidden']").map(function(i,e) { 
            				return e.value;
            			})
            			var issueKeys = [];
            			for (i in issueKeysEl) {
            				if ($.isNumeric(i)) {
            					issueKeys.push(issueKeysEl[i])
            				}
            			}
            			var self = this;
            			$.ajax({
                             url: '/ws/issues/reorder',
                             type: 'post',
                             contentType: 'application/json',
                             data: JSON.stringify(issueKeys),
                             error: function (jqXhr, textStatus, errorThrown) {
                            	 self.fire("iron-signal", {name:"show-error-message", data:"Repriorization failed. Reason: status ("+jqXhr.status+") " + textStatus	})
                            	 si.sortable("cancel");
                            	 var card = ui.item.find(".issue")
                            	 var original = card.css('backgroundColor');
                            	 card.animate({backgroundColor:"red"},300).animate({backgroundColor:original},800)
                            	 var parent = ui.item.closest(".board-lane.table-wrapper");
                            	 parent.animate({scrollTop: 
                            		 ui.item.offset().top - parent.offset().top
                            	 })
                             }
                         });
            		}.bind(this);
            		this.stepItem().sortable({
                		items: 'issue-item',
                		opacity: 0.7,
                		animation: 150,
                		forceHelperSize: true,
                		forcePlaceholderSize: true,
                		stop: handle
                	});
                },
                
                stepItem: function() {
                	return $(this.$.boardStep);
                },

                showParentIconInSynthetic: function() {
                    return this.parentLaneConfig.showParentIconInSynthetic;
                },

                showTeamCount: function() {
                    return userPreferences.getPreferences().laneConfiguration[0].showCount && this.getIssueCount() > 0;
                },

                showSynthetic: function() {
                    return userPreferences.getView().showSynthetic;
                },

                getParentLane: function() {
                    return taskboard.getLane(this.parentLaneId);
                },

                getOptimalIssueWidth: function(columns) {
                    return 'width: '+(100/columns)+'%';
                },

                filter: function() {
                    if(this.issues)
                        this.set('filteredIssues', this.filterIssues(this.issues));
                },

                filterIssues: function(issues) {
                    var filteredIssues = new Array();
                    for (var i in issues)
                        if (this.shouldShowIssue(issues[i]))
                            filteredIssues.push(issues[i]);

                    return filteredIssues;
                },

                filterIssuesInvalidTeam: function(issues) {
                    checkingInvalidTeam = true;
                    var issuesInvalidTeam = this.filterIssues(issues);
                    checkingInvalidTeam = false;
                    return issuesInvalidTeam;
                },

                filterIssuesDisabledTeam: function(issues) {
                    var bkpTeam = this.team;
                    this.team = null;
                    var issuesDisabledTeam = this.filterIssues(issues);
                    this.team = bkpTeam;
                    return issuesDisabledTeam;
                },

                getSorter: function () {
                    return sortIssue.sortByOrder;
                },

                shouldShowIssue: function(issue) {
                    return this.doFiltersAllow(issue) && this.doPreferencesAllow(issue) &&
                            searchFilter.match(issue, this.search) &&
                            this.hierarchicalFilterMatches(issue);
                },

                doFiltersAllow: function(issue) {
                    if (checkingInvalidTeam)
                        return true;

                    if (taskboard.isInvalidTeam(issue.teams))
                        return false;

                    if (!this.team || issue.teams.indexOf(this.team) !== -1)
                        return true;

                    return false;
                },

                doPreferencesAllow: function(issue) {
                    for (var i = 0; i < taskboard.getAspectFilters().length; i++) {
                        var field = taskboard.getAspectFilters()[i].field;
                        var value = issue[field]
                        var filters = userPreferences.getFilters()

                        if (checkingInvalidTeam && field == 'teams')
                            continue;

                        if (!this.checkPreference(value,  filters))
                            return false;
                    }

                    return true;
                },

                checkPreference: function(values, filters) {
                    if (!Array.isArray(values))
                        values = [ values ];

                    for (var index in values) {
                        if (filters[values[index]])
                            return true;
                    }

                    return false;
                },

                hierarchicalFilterMatches: function(issue) {
                    return taskboard.getRootHierarchicalFilter() && issue.hierarchyMatch || !taskboard.getRootHierarchicalFilter();
                },

                getIssueCount: function() {
                    return this.filteredIssues.length;
                },

                refit: function() {
                    var rowNode = this.parentNode.parentNode;
                    var totalStepWeight = this.getParentLane().getTotalStepWeight();
                    var weight = this.stepMetadata.weight;
                    var size = rowNode.offsetWidth * weight / totalStepWeight;
                    this.columns = Math.min(Math.max(Math.floor(size / this.idealIssueSize), 1), this.getIssueCount());
                },

                preferencesUpdated: function() {
                    this.filter();
                    this.lastPreferenceUpdate = new Date();
                },

                searchFilterChanged: function(event, data) {
                    this.search = data;
                    this.preferencesUpdated();
                },
                
                handleUpdatedIssues: function(event, data) {
                    if (this.issues.length === 0) return;
                	var issueBoardStep = taskboard.getIssueStep(data.issue)
                	var belongsToThisStep = this.stepMetadata.id === issueBoardStep.id;
                	
                	var issueIndex = -1
                    this.issues.forEach(function(anIssue, index, array) {
                 	    if (anIssue.issueKey == data.issue.issueKey) {
                 	       issueIndex = index;
                 	        if (belongsToThisStep)
                 	        	array[index] = data.issue;
                 	    }
                    })
                    if (belongsToThisStep && issueIndex == -1) {
                        // issue added to this board step
                        data.issue.__eventInfo.type = 'ADDED'
                        data.issue.boardstep = issueBoardStep.id;
                        this.issues.push(data.issue)
                        
                        var self = this;
                        this.async(function() {
                            self.filter();
                            this.fire("iron-signal", {name:"issue-count-changed"});
                        })
                        
                        return;
                    }
                    
                    if (!belongsToThisStep && issueIndex > -1) {
                        // issue removed from this board step
                        var self = this;
                        var issueToRemoveDom = Polymer.dom(this.root).querySelector("#"+data.issue.issueKey);
                        
                        $(issueToRemoveDom).fadeOut(
                            500,
                            function() {
                                self.issues.splice(issueIndex,1);
                                this.async(function() {
                                    $(issueToRemoveDom).fadeIn(0);
                                    self.filter();
                                    // make sure the header counters are updated to reflect the correct count
                                    this.fire("iron-signal", {name:"issue-count-changed"});
                                })
                            }
                        )
                        return;
                    }
                }
            });
        })();
    </script>

</dom-module>
