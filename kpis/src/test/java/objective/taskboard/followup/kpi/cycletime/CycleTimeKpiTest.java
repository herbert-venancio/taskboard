package objective.taskboard.followup.kpi.cycletime;

import org.junit.Test;

import objective.taskboard.followup.kpi.enviroment.DSLKpi;

public class CycleTimeKpiTest {

    @Test
    public void cycleTime_happyDay() {
        dsl()
            .environment()
                .givenSubtask("I-1")
                    .type("Development")
                    .project("TASKB")
                    .withTransitions()
                        .status("Open").date("2019-01-01")
                        .status("To Do").date("2019-01-02")
                        .status("Doing").date("2019-01-03")
                        .status("To Review").date("2019-01-04")
                        .status("Reviewing").date("2019-01-05")
                        .status("Done").date("2019-01-06")
                        .status("Cancelled").noDate()
                    .eoT()
                .eoI()
                .withKpiProperties()
                    .withSubtaskCycleTimeProperties("To Do","Doing","To Review","Reviewing")
                .eoKpi()
            .then()
                .assertThat()
                    .cycleTimeKpi("I-1")
                        .startsAt("2019-01-02")
                        .endsAt("2019-01-06")
                        .hasTotalCycleTime(5)
                        .hasSubCycles()
                            .subCycle("To Do").hasCycleTimeInDays(1)
                            .subCycle("Doing").hasCycleTimeInDays(1)
                            .subCycle("To Review").hasCycleTimeInDays(1)
                            .subCycle("Reviewing").hasCycleTimeInDays(1)
                        .eoSC();
    }

    @Test
    public void cycleTime_whenJumpingStatus_thenShouldntHaveCycleTime() {
        dsl()
            .environment()
                .givenSubtask("I-1")
                    .type("Development")
                    .project("TASKB")
                    .withTransitions()
                        .status("Open").date("2019-01-01")
                        .status("To Do").date("2019-01-02")
                        .status("Doing").noDate()
                        .status("To Review").noDate()
                        .status("Reviewing").noDate()
                        .status("Done").date("2019-01-06")
                        .status("Cancelled").noDate()
                    .eoT()
                .eoI()
                .withKpiProperties()
                    .withSubtaskCycleTimeProperties("To Do","Doing","To Review","Reviewing")
                .eoKpi()
            .then()
                .assertThat()
                    .cycleTimeKpi("I-1")
                        .startsAt("2019-01-02")
                        .endsAt("2019-01-06")
                        .hasTotalCycleTime(5)
                        .hasSubCycles()
                            .subCycle("To Do").hasCycleTimeInDays(4)
                            .subCycle("Doing").hasNoCycle()
                            .subCycle("To Review").hasNoCycle()
                            .subCycle("Reviewing").hasNoCycle()
                        .eoSC();
    }

    @Test
    public void cycleTime_whenJumpingStatus_withWorklogOnThem_thenShouldHaveCycleTime() {
        dsl()
            .environment()
                .givenSubtask("I-1")
                    .type("Development")
                    .project("TASKB")
                    .withTransitions()
                        .status("Open").date("2019-01-01")
                        .status("To Do").date("2019-01-02")
                        .status("Doing").noDate()
                        .status("To Review").noDate()
                        .status("Reviewing").date("2019-01-05")
                        .status("Done").date("2019-01-06")
                        .status("Cancelled").noDate()
                    .eoT()
                    .worklogs()
                        .at("2019-01-03").timeSpentInHours(1)
                    .eoW()
                .eoI()
                .withKpiProperties()
                    .withSubtaskCycleTimeProperties("To Do","Doing","To Review","Reviewing")
                .eoKpi()
            .then()
                .assertThat()
                    .cycleTimeKpi("I-1")
                        .startsAt("2019-01-02")
                        .endsAt("2019-01-06")
                        .hasTotalCycleTime(5)
                        .hasSubCycles()
                            .subCycle("To Do").hasCycleTimeInDays(1)
                            .subCycle("Doing").hasCycleTimeInDays(2)
                            .subCycle("To Review").hasNoCycle()
                            .subCycle("Reviewing").hasCycleTimeInDays(1)
                        .eoSC();
    }

    @Test
    public void cycleTime_whenJumpingStatus_withMultipleWorklogOnThem_thenShouldHaveCycleTime_countingTheEarliestWorklogDate() {
        dsl()
            .environment()
                .givenSubtask("I-1")
                    .type("Development")
                    .project("TASKB")
                    .withTransitions()
                        .status("Open").date("2019-01-01")
                        .status("To Do").date("2019-01-02")
                        .status("Doing").noDate()
                        .status("To Review").noDate()
                        .status("Reviewing").date("2019-01-05")
                        .status("Done").date("2019-01-06")
                        .status("Cancelled").noDate()
                    .eoT()
                    .worklogs()
                        .at("2019-01-03").timeSpentInHours(1)
                        .at("2019-01-04").timeSpentInHours(1)
                        .at("2019-01-05").timeSpentInHours(1)
                    .eoW()
                .eoI()
                .withKpiProperties()
                    .withSubtaskCycleTimeProperties("To Do","Doing","To Review","Reviewing")
                .eoKpi()
            .then()
                .assertThat()
                    .cycleTimeKpi("I-1")
                        .startsAt("2019-01-02")
                        .endsAt("2019-01-06")
                        .hasTotalCycleTime(5)
                        .hasSubCycles()
                            .subCycle("To Do").hasCycleTimeInDays(1)
                            .subCycle("Doing").hasCycleTimeInDays(2)
                            .subCycle("To Review").hasNoCycle()
                            .subCycle("Reviewing").hasCycleTimeInDays(1)
                        .eoSC();
    }

    @Test
    public void cycleTime_withDate_withMultipleWorklogOnThem_thenShouldHaveCycleTime_countingTheEarliestOfAllDates() {
        dsl()
            .environment()
                .givenSubtask("I-1")
                    .type("Development")
                    .project("TASKB")
                    .withTransitions()
                        .status("Open").date("2019-01-01")
                        .status("To Do").date("2019-01-02")
                        .status("Doing").date("2019-01-04")
                        .status("To Review").noDate()
                        .status("Reviewing").date("2019-01-05")
                        .status("Done").date("2019-01-06")
                        .status("Cancelled").noDate()
                    .eoT()
                    .worklogs()
                        .at("2019-01-03").timeSpentInHours(1)
                        .at("2019-01-04").timeSpentInHours(1)
                        .at("2019-01-05").timeSpentInHours(1)
                    .eoW()
                .eoI()
                .withKpiProperties()
                    .withSubtaskCycleTimeProperties("To Do","Doing","To Review","Reviewing")
                .eoKpi()
            .then()
                .assertThat()
                    .cycleTimeKpi("I-1")
                        .startsAt("2019-01-02")
                        .endsAt("2019-01-06")
                        .hasTotalCycleTime(5)
                        .hasSubCycles()
                            .subCycle("To Do").hasCycleTimeInDays(1)
                            .subCycle("Doing").hasCycleTimeInDays(2)
                            .subCycle("To Review").hasNoCycle()
                            .subCycle("Reviewing").hasCycleTimeInDays(1)
                        .eoSC();
    }

    @Test
    public void cycleTime_whenAllTransitionsWereMadeAtTheSameDay_thenShouldNotHaveSubCycle() {
        dsl()
            .environment()
                .givenSubtask("I-1")
                    .type("Development")
                    .project("TASKB")
                    .withTransitions()
                        .status("Open").date("2019-01-01")
                        .status("To Do").date("2019-01-01")
                        .status("Doing").date("2019-01-01")
                        .status("To Review").date("2019-01-01")
                        .status("Reviewing").date("2019-01-01")
                        .status("Done").date("2019-01-01")
                        .status("Cancelled").date("2019-01-01")
                    .eoT()
                .eoI()
                .withKpiProperties()
                    .withSubtaskCycleTimeProperties("To Do","Doing","To Review","Reviewing")
                .eoKpi()
            .then()
                .assertThat()
                    .cycleTimeKpi("I-1")
                        .startsAt("2019-01-01")
                        .endsAt("2019-01-01")
                        .hasTotalCycleTime(1)
                        .hasSubCycles()
                            .subCycle("To Do").hasNoCycle()
                            .subCycle("Doing").hasNoCycle()
                            .subCycle("To Review").hasNoCycle()
                            .subCycle("Reviewing").hasNoCycle()
                        .eoSC();
    }

    @Test
    public void cycleTime_whenSomeTransitionsWereMadeAtTheSameDay_andOtherStatusDoesNotHaveTransitions_thenThoseWithDifferentDateTransitionsShouldHaveCycle() {
        dsl()
            .environment()
                .givenSubtask("I-1")
                    .type("Development")
                    .project("TASKB")
                    .withTransitions()
                        .status("Open").date("2019-01-01")
                        .status("To Do").date("2019-01-02")
                        .status("Doing").date("2019-01-05")
                        .status("To Review").noDate()
                        .status("Reviewing").date("2019-01-05")
                        .status("Done").date("2019-01-08")
                        .status("Cancelled").noDate()
                    .eoT()
                .eoI()
                .withKpiProperties()
                    .withSubtaskCycleTimeProperties("To Do","Doing","To Review","Reviewing")
                .eoKpi()
            .then()
                .assertThat()
                    .cycleTimeKpi("I-1")
                        .startsAt("2019-01-02")
                        .endsAt("2019-01-08")
                        .hasTotalCycleTime(7)
                        .hasSubCycles()
                            .subCycle("To Do").hasCycleTimeInDays(3)
                            .subCycle("Doing").hasNoCycle()
                            .subCycle("To Review").hasNoCycle()
                            .subCycle("Reviewing").hasCycleTimeInDays(3)
                        .eoSC();
    }

    @Test
    public void cycleTime_whenWorklogRegisteredAfterIssueIsClosed_thenCycleForThePreviousStatusShouldConsiderTheWorklogDate_andStatusFromWorklogShouldHaveNoCycle() {
        dsl()
            .environment()
                .givenSubtask("I-1")
                    .type("Development")
                    .project("TASKB")
                    .withTransitions()
                        .status("Open").date("2019-01-01")
                        .status("To Do").date("2019-01-02")
                        .status("Doing").date("2019-01-03")
                        .status("To Review").date("2019-01-04")
                        .status("Reviewing").date("2019-01-05")
                        .status("Done").date("2019-01-06")
                        .status("Cancelled").noDate()
                    .eoT()
                    .worklogs()
                        .at("2019-01-08").timeSpentInHours(1)
                    .eoW()
                .eoI()
                .withKpiProperties()
                    .withSubtaskCycleTimeProperties("To Do","Doing","To Review","Reviewing")
                .eoKpi()
            .then()
                .assertThat()
                    .cycleTimeKpi("I-1")
                        .startsAt("2019-01-02")
                        .endsAt("2019-01-08")
                        .hasTotalCycleTime(7)
                        .hasSubCycles()
                            .subCycle("To Do").hasCycleTimeInDays(1)
                            .subCycle("Doing").hasCycleTimeInDays(1)
                            .subCycle("To Review").hasCycleTimeInDays(1)
                            .subCycle("Reviewing").hasCycleTimeInDays(3)
                        .eoSC();
    }

    @Test
    public void cycleTime_whenWorklogAfterDoneAndSkippedReviewing_thenReviewingEnterDateIsTheWorklogsMinimumDateAndExitDateIsTheWorklosgMaximumDate() {
        dsl()
            .environment()
                .givenSubtask("I-1")
                    .type("Development")
                    .project("TASKB")
                    .withTransitions()
                        .status("Open").date("2019-01-01")
                        .status("To Do").date("2019-01-02")
                        .status("Doing").date("2019-01-03")
                        .status("To Review").date("2019-01-04")
                        .status("Reviewing").noDate()
                        .status("Done").date("2019-01-06")
                        .status("Cancelled").noDate()
                    .eoT()
                    .worklogs()
                        .at("2019-01-08").timeSpentInHours(1)
                        .at("2019-01-09").timeSpentInHours(2)
                    .eoW()
                .eoI()
                .withKpiProperties()
                    .withSubtaskCycleTimeProperties("To Do","Doing","To Review","Reviewing")
                .eoKpi()
            .then()
                .assertThat()
                    .cycleTimeKpi("I-1")
                        .startsAt("2019-01-02")
                        .endsAt("2019-01-09")
                        .hasTotalCycleTime(8)
                        .hasSubCycles()
                            .subCycle("To Do").hasCycleTimeInDays(1)
                            .subCycle("Doing").hasCycleTimeInDays(1)
                            .subCycle("To Review").hasCycleTimeInDays(4)
                            .subCycle("Reviewing").hasCycleTimeInDays(1)
                        .eoSC();
    }

    @Test
    public void cycleTime_whenWorklogDateBeforeDone_thenDoingEnterDateIsTheMinimumOfWorklogsDatesAndExitDateIsTheMaximumOfWorklogsDates() {
        dsl()
            .environment()
                .givenSubtask("I-1")
                    .type("Development")
                    .project("TASKB")
                    .withTransitions()
                        .status("Open").date("2019-01-01")
                        .status("To Do").date("2019-01-02")
                        .status("Doing").date("2019-01-03")
                        .status("To Review").date("2019-01-04")
                        .status("Reviewing").date("2019-01-05")
                        .status("Done").date("2019-01-06")
                        .status("Cancelled").noDate()
                    .eoT()
                    .worklogs()
                        .at("2019-01-01").timeSpentInHours(1)
                    .eoW()
                .eoI()
                .withKpiProperties()
                    .withSubtaskCycleTimeProperties("To Do","Doing","To Review","Reviewing")
                .eoKpi()
            .then()
                .assertThat()
                    .cycleTimeKpi("I-1")
                        .startsAt("2019-01-01")
                        .endsAt("2019-01-06")
                        .hasTotalCycleTime(6)
                        .hasSubCycles()
                            .subCycle("To Do").hasCycleTimeInDays(0)
                            .subCycle("Doing").hasCycleTimeInDays(3)
                            .subCycle("To Review").hasCycleTimeInDays(1)
                            .subCycle("Reviewing").hasCycleTimeInDays(1)
                        .eoSC();
    }

    @Test
    public void cycleTime_whenWorklogDateBeforeDoingAndSkippedDoing_thenDoingEnterDateIsTheMinimumOfWorklogsDatesAndExitDateIsTheMaximumOfWorklogsDates() {
        dsl()
            .environment()
                .givenSubtask("I-1")
                    .type("Development")
                    .project("TASKB")
                    .withTransitions()
                        .status("Open").date("2019-01-02")
                        .status("To Do").date("2019-01-02")
                        .status("Doing").noDate()
                        .status("To Review").date("2019-01-04")
                        .status("Reviewing").date("2019-01-05")
                        .status("Done").date("2019-01-06")
                        .status("Cancelled").noDate()
                    .eoT()
                    .worklogs()
                        .at("2019-01-01").timeSpentInHours(1)
                    .eoW()
                .eoI()
                .withKpiProperties()
                    .withSubtaskCycleTimeProperties("To Do","Doing","To Review","Reviewing")
                .eoKpi()
            .then()
                .assertThat()
                    .cycleTimeKpi("I-1")
                        .startsAt("2019-01-01")
                        .endsAt("2019-01-06")
                        .hasTotalCycleTime(6)
                        .hasSubCycles()
                            .subCycle("To Do").hasCycleTimeInDays(0)
                            .subCycle("Doing").hasCycleTimeInDays(3)
                            .subCycle("To Review").hasCycleTimeInDays(1)
                            .subCycle("Reviewing").hasCycleTimeInDays(1)
                        .eoSC();
    }

    private DSLKpi dsl() {
        DSLKpi dsl = new DSLKpi();
        dsl.environment()
            .statuses()
                .withProgressingStatuses("Doing","Reviewing")
                .withNotProgressingStatuses("Open","To Do","To Review","Cancelled","Done")
            .eoS()
            .withSubtaskType("Development");
        return dsl;
    }
}
